# http 常用http header及浏览器缓存

## http header

##### Accept（HTTP请求头）

表示客户端期望服务器返回的媒体格式。客户端期望的资源类型服务器可能没有，所以客户端会期望多种类型，并设置优先级，服务器根据优先级寻找相应的资源返回给客户端。

```
# 注意：先逗号分割类型，再分号分割属性
Accept: audio/*; q=0.2, audio/basic // (audio/*; q=0.2), audio/basic
```

表示audio/basic类型的资源优先，如果没有，就随便其它什么格式的audio资源都可以。q的取值范围是(0-1]，其具体值并没有意义，它仅用来排序优先级，如果没有q，默认q=1，也就是最高优先级。

##### Accept-Charset（HTTP请求头）

表示客户端期望服务器返回的内容的编码格式。它同Accept头一样，也可以指定多个编码，以q值代表优先级。

```
# 注意：先逗号分割类型，再分号分割属性
Accept-Charset: utf8, gbk; q=0.6
```

表示utf8编码优先，如果不行，就拿gbk编码返回.

##### Content-Type（HTTP实体头）

Content-Type是服务器向客户端发送的头，代表内容的媒体类型和编码格式，是对Accept头和Accept-Charset头的统一应答。

```
Content-Type: text/html; charset=utf8
```

表示返回的Body是个html文本，编码为utf8

![](./img/v2-85d10d5996011a78b503433918d36e83_1440w.webp)

##### Accept-Language（HTTP请求头）

表示客户端期望服务器返回的内容的语言。很多大型互联网公司是全球化的，它的技术文档一般有有多种语言，通过这个字段可以实现文档的本地化，对国内用户呈现简体中文文档，对英语系用户呈现英文文档。

```
Accept-Language:zh-CN,en-US;q=0.8,zh-TW;q=0.6
```

表示大陆简体中文优先，其次英语，再其次台湾繁体中文

##### Content-Language（HTTP实体头）

这个头字段内容是对Accept-Language的应答。服务器通过此字段告知客户端返回的Body信息的语言是什么。

![](./img/v2-de018f6c2b4834916beb22c669746897_1440w.webp)

##### Content-Length（HTTP实体头）

表示传输的请求 / 响应的Body的长度。GET请求因为没有Body，所以不需要这个头。携带Body的并且可以提前知道Body长度的请求 / 响应必须带上这个字段，以便对方可以方便的分辨出报文的边界，也就是Body数据何时结束。如果Body太大，需要边计算边传输，不到最后计算结束是无法知道整个Body大小的，这个时候可以使用http分块传输，这个时候也是不需要Content-Length字段的。

##### Content-Location（HTTP实体头）

当客户端请求的资源在服务器有多个地址时，服务器可以通过Content-Location字段告知客户端其他的可选地址。这个字段比较少见。

##### Content-MD5（HTTP实体头）

在Header中提供这个信息是用来做Body内容校验。它表示Body信息被md5算法处理后的base64字符串。这个字段也比较少见。因为校验机制在TCP层已经实现了，再来一层校验并没有多大意义。另外资源的md5值往往放在后面的ETag头信息中作为资源的唯一标识来使用。

##### Date（HTTP通用头）

如果服务器没有缓存，那么Date就是响应的即使生成时间。如果服务器设有缓存，那么Date就是响应内容被缓存的时间。它必须服务规范里定义的特定格式，这种格式叫做HTTP-Date，不支持随意定义自己的时间格式。

```
Date: Tue, 15 Nov 1994 08:12:31 GMT
```

##### Age（HTTP响应头）

表示资源缓存的年龄，也就是资源自缓存以来到现在已经过去了多少时间，单位为秒。

```
Age: 86400
```

##### Expires（HTTP实体头）

服务器使用Expires头来告知对方资源何时失效。如果它的值等于Date的头，则表示资源已经失效。

```
Expires: Thu, 01 Dec 1994 16:00:00 GMT
```

##### Etag（HTTP实体头）

资源标签，每个资源可以提供多个标签信息。它一般用来和下面的If-Match和If-None-Match配合使用，用来判断缓存资源的有效性。比较常见的标签是自愿的版本号，比如可以拿资源数据的mdf校验码作为版本号。


##### If-Match（HTTP请求头）

If-Match的值一般是上面提到的ETag的值，它常用于Http的乐观锁。所谓Http乐观锁，是指客户端先Get这个资源得到ETag中的版本号，然后发起一个资源修改请求 PUT/PATCH 时通过If-Match头来制定资源的版本号，如果服务器资源满足If-Match中指定的版本号，请求就会执行。如果不满足，说明资源被并发修改了，就需要返回状态码为412 Precondition failed 的错误。客户端可以选择放弃或者重试整个过程。

##### If-None-Match（HTTP请求头）

类似于If-Match，只是条件相反。

![](./img/v2-d70365975bb61636e00a8d79bd9ad14e_1440w.webp)

##### ETag vs Last-Modified vs Expires

ETag一般携带的是资源的版本号，协议没有具体规定版本号是什么。它可以是资源的md5校验码，也可以是uuid，甚至可以是自增的数字，也可以是资源的修改时间。它的匹配方式是相等/不相等。因为服务器需要维护版本号，取决的版本号是什么，这可能是一个存储和计算的负担。

Last-Modified携带的资源的修改时间。它的匹配方式是大于/小于。如果是静态资源文件，一般就是操作系统记录的文件修改时间。

Expires是服务器告知客户端资源的过期时间。客户端缓存的资源在这个时间之后自动过期，而不需要非得向服务器确认一下是不是304 Not Modified才认为没过期。

##### Allow（HTTP实体头）

表示资源支持访问的 HTTP Method 类型。它是服务器对客户端的建议，告知对方请使用Allow中提到的Method来访问资源。

```
Allow: GET, HEAD, PUT
```

##### Connection（HTTP通用头）

当客户端和服务器需要协商连接的属性时，可以使用Connection属性头部。比较常用的一个属性是Close，用来通知对方在当前请求结束后关闭连接。

```
Connection: close
```

##### Expect（HTTP请求头）

用于请求发送之前向服务器询问许可。譬如要向服务器发送一个很大的文件而不确定是否超出限制，就可以在请求头里携带一个Expece头部。

```
Expect: 100-continue
```

如果服务器说不行，就会返回417 Expectation Failed错误告诉客户端放弃。如果可以那就返回100-continue状态码告知客户端放马过来吧，于是客户端就会继续上传Body内容。如果服务器提前收到Body内容就会放弃返回100-continue响应。

##### From（HTTP请求头）

该字段一般用来标记请求发起者的邮件地址，相当于给请求赋予一个责任人。如果服务器发现请求出现问题，就会通过此字段联系到发起人进行处理。因为邮件地址涉及到隐私信息，所以请求携带From头需要经过用户同意。RFC协议建议所有的机器人代理发起的请求应该携带此头部，以免遇到问题时可以找到责任人。不过如果是恶意的机器人，估计这样的建议也只是耳边风而已。

##### Host（HTTP请求头）

RFC协议规定所有的HTTP请求必须携带Host头，即使Host没有值，也必须带上Host头附加一个空串，如果不满足，应用服务器应该抛出400 bad Request。协议虽然这样规定，不过大部分网关或者服务器都比较仁慈，既然没有指定Host字段，那就默认给你加上一个。网关代理可以根据不同的Host值转发到不同的upstream服务节点，它常用于虚拟主机服务业务。

![](./img/v2-90aba5efb31e01609f2c7f09b4eca2f0_1440w.webp)

##### Last-Modified（HTTP实体头）

标记资源的最近修改时间，它和Date比较类似，区别是Last-Modified代表修改时间，而Date是创建时间。

##### If-Modified-Since（HTTP请求头）

浏览器向服务器请求静态资源时，如果浏览器本地已经有了缓存，就会携带If-Last-Modified头，值为资源的Last-Modified时间，询问服务器该资源自从这个Last-Modified时间之后有没有被修改。如果没有修改过，就会向浏览器返回304 Not Modified通知浏览器可以放心使用缓存内的资源。如果资源修改过，那就像正常的get请求一样，携带资源的内容返回200 OK

##### If-Unmodified-Since（HTTP请求头）

类似于If-Modified-Since，意义相反。区别是当服务器资源条件不满足时，不是返回304 Not Modified，而是返回412 Precondition Failed。

![](./img/v2-187e580e806d0052cc7418c59ea286e6_1440w.png)

##### Range（HTTP请求头）

支持断电续传的服务器必须处理Range头，它表示客户端请求资源的一部分时指定的请求字节范围。它是客户端向服务器发送的请求头。

```
Range: bytes=500-999
```

##### Content-Range（HTTP实体头）

针对上面的Range头，服务器响应客户端时也需提供相应的Content-Range头，表示传输的Body数据在整体资源快中的字节范围。比如下面的例子表示资源总共有47022字节，当前响应的内容是21010-47021字节之间的内容。

```
Content-Range: bytes 21010-47021/47022
```

之所以是47021而不是47022是因为offset是以0开始的，47021就是最后一个字节。

##### If-Range（HTTP请求头）

在断点续传时，为确保连续2个请求之间服务器资源本身没有发生变化，需要If-Range头带上ETag的资源版本号。服务器资源根据这个版本号来判定资源是否改变了。如果没变，就返回206 Partial Content将不分资源返回。如果资源变了，那就相当于一个普通的GET请求，返回200 OK和整个资源内容。

![](./img/v2-fc2c943940b3e59af54225c0e73855bc_1440w.webp)

##### Location（HTTP实体头）

服务器向客户端发送302跳转的时候，总会携带Location头信息，它的值为目标URL。

```
HTTP/1.1 302 Temporary Redirect
Location: https://www-temp.example.org/
```

##### Max-Forwards（HTTP请求头）

用来限定网关或者代理的层数，也就是最大转发次数。HTTP每经过一个网关或者代理层，Max-Forwards值就要减1。如果nginx接收到前端请求的时候Max-Forwards已经等于0，那么它就不应该再将请求转发到upstream指定的服务节点上。

##### Pragma（HTTP通用头）

这个头是比较常见的，在前端开发模式下经常会加上这个头部。

```
Pragma: no-cache
```

当网关收到一个带有这样请求的头部时，即使内部存在该请求资源的缓存并且有效也不可以直接发送给客户端，而必须转发给后面的upstream进行处理。
不过如果真的所有的网关都遵循这个协议的话，攻击是很容易构造的，所以它一般仅用于开发模式，防止静态资源修改后前端得不到即时更新。其它值的pragma值没有遇到过。

##### Referer（HTTP请求头）

Referer是非常常用的头，它表示请求的发起来源URI，也就是当前页面资源的父页面。如果你从A页面跳转到B页面，那么请求B页面的请求头里面就会有Referer信息，它的值就是A页面的访问地址。通过追踪Referer，可得出资源页面之间复杂的跳转链，它非常适合用于网页的数据分析和路径优化。

![](./img/v2-37640353742e26a07dae704a800ed4ed_1440w.webp)

##### Retry-After（HTTP响应头）

服务器升级时，来自客户端的请求会直接给予503(Service Unavailable)错误，通过在返回头里面加入Retry-After字段告知客户端何时服务可以恢复正常访问。Retry-After的头可以是HTTP-Date，也可以是整数，表示多少秒后服务可以恢复正常访问。浏览器在拿到这个值之后可以考虑增加一个定时器在未来的某个时间进行重试。

##### Server（HTTP响应头）

用于返回服务器相关的软件信息，来告知客户端当前的HTTP服务是由某某软件提供的，可以看成是一种软件广告。
RFC协议里对这个头信息做了警告：暴露出服务器信息可能会导致黑客更易于攻击你的服务，建议谨慎使用。

##### User-Agent（HTTP请求头）

携带当前的用户代理信息，一般包含浏览器、浏览器内核和操作系统的版本型号信息。它和Server头是对应的，一个是表达服务器信息，一个是表达客户端信息。服务器可以根据用户代理信息统计出网页服务的浏览器、操作系统的使用占比情况，服务器也可以根据UA的信息来定制不一样的内容。

![](./IMG/v2-7ab8dbaf1d901f4cd7c985cd2b4aa09c_1440w.webp)

##### Transfer-Encoding（HTTP通用头）

传送Body信息时需要对Body数据采取何种变换。当HTTP对Body进行分块传送时，需要增加下面的头部信息才可以进行分块传送。其它类型目前没有遇到过。

```
Transfer-Encoding: chunked
```

##### Upgrade（HTTP通用头）

服务器建议客户端升级传输协议。比如当客户端使用HTTP/1.0发送请求时，服务器就可以建议客户端升级到HTTP/1.1。
这个时候就可以使用Upgrade头。客户端收到这个Upgrade后就会将后续请求转成HTTP/1.1格式继续进行交流。可以支持多个参数，使用逗号分割即可。

```
Upgrade: HTTP/1.1
```

当客户端要和服务器进行Websocket进行通讯时，在握手阶段服务器也会向客户端发送Upgrade头部信息，提示客户端将协议切换到Websocket。

```
Upgrade: WebSocket
```

##### Vary（HTTP响应头）

该头部用于缓存控制。对于一些缓存服务器，我们在请求里加入Vary参数可以告知缓存服务器对不同的Vary参数的响应使用不同的缓存单元。比如Vary参数里放入编码参数，那么不同编码的网页就会有不同的缓存。Vary的值可以有多个，只要任意一个值不一样就会有不同的缓存。
比如下面的这个例子告知缓存服务器对不同语言和不同编码的网页响应使用不同的缓存单元。

```
Vary: Accept-Encoding,Accept-Language
```

##### Via（HTTP通用头）

该字段用来标识一个请求经过的网关路由节点。如果这个请求经过了多个代理层，Via头部就会有多个网关信息。

##### Warning（HTTP响应头）

用于在响应中添加一些附加的警告信息，警告信息包含一个错误码和错误说明。通用的一些错误码在RFC协议中有具体规定。比如111号错误码表示缓存服务器的缓存项目已经过期，并且尝试reload资源，但是reload失败了，所以只好返回了旧的已经过期的内容，这个时候就需要通过warning头反馈客户端。

```
Warning: 111 Revalidation failed
```

##### WWW-Authenticate（HTTP响应头）

WWW-Authenticate是401 Unauthorized错误码返回时必须携带的头，该头会携带一个问题Challenge给客户端，告知客户端需要携带这个问题的答案来请求服务器才可以继续访问目标资源。这种问题Challenge可以自定义，比较常见的是Basic认证。

```
WWW-Authenticate: Basic realm=xxx
```

Basic指代base64加密算法(不安全)，realm指代认证范围/场合/情景名称。

##### Authorization（HTTP请求头）

对于某些需要特殊权限才能访问的资源需要客户端在请求里提供用户名密码的认证信息。它是对WWW-Authenticate的应答。

```
# value = base64(user_name:password)
Authorization: Basic YWRtaW46YWRtaW4xMjM=
```

![](./img/v2-6ed523e9fec2f4e754837fbc8bc5a197_1440w.webp)

##### Proxy-Authenticate（HTTP请求头）

同WWW-Authorization头部，用于代理服务器认证。

##### Proxy-Authorization（HTTP请求头）

同Authorization头部，用于代理服务器认证。

##### Cache-Control（HTTP通用头）

这可能是http头里面最复杂的一个头了。这个头既可以用于请求，也可以用于响应。在请求和响应的取值不一样，分别代表了不同的意思。

1、no-cache 如果no-cache没有指定值，那就表示不允许缓存。对于请求来说，服务器不得使用缓存内容直接返回。对于响应来说，客户端不得缓存服务端响应的资源内容。如果no-cache指定了值，那就表示值对应的头信息不得使用缓存，其他的信息还是可以缓存的。告知对方我只要最新的数据。

2、no-store 告诉对方不要持久化 请求/响应 数据到其他地方，这种信息是敏感的，要保持它的易失性。告知对方记在心里(memory)就行，别写在纸上(disk)。

3、no-transform 告知对方不要转换数据。比如客户端上传了raw图像数据，服务器一般都会选择性压缩图像数据进行存储。no-transform告知对方保留原始数据信息，不要进行任何转换。告知对方不要乱动我发过来的东西。

4、only-if-cached 用于请求头，告知服务器只要那些已经缓存的内容，不要去reload。如果没有缓存内容就返回504 Gateway Timeout错误。表示客户端不想太麻烦服务器，有就给，没就算了。

5、max-age 用于请求头。限制缓存内容的年龄，如果超过max-age年龄的，需要服务器去reload内容资源。这叫客户端的年龄歧视。

6、max-stale 用于请求头。客户端允许服务器返回缓存已过期的资源内容，但是限定了最大过期时间。表示客户端虽然很宽容，但那也是有限度的。

7、min-fresh 用于请求头。客户端限制服务器不要那些即将过期的资源内容。就好比我们去超市买牛奶，如果牛奶快过期了虽然还在保质期内咱们也就不会考虑。

8、public 用于响应头。表示允许客户端缓存响应信息，并可以给别人使用。比如代理服务器缓存静态资源供所有代理用户使用。

9、private 用于响应头。表示仅允许客户端缓存响应信息给自己使用，不得分享给别人。这样是为了禁止代理服务器进行缓存，而允许客户端自己缓存资源内容。意思是你个人留着用行，别借给别人用。

## 浏览器缓存策略

浏览器的缓存过程如下

- 开始加载，域名解析，DNS缓存
- 本地缓存（memory缓存）
- Http缓存（强缓存和协商缓存）
- 服务端缓存（cdn缓存）

##### DNS缓存

通常我们输入一个网址，它包含了域名和端口可以指定唯一的IP地址，然后建立连接进行通信，而域名查找IP地址的过程就是dns解析。

```
www.dnscache.com (域名) - DNS解析 -> 11.222.33.444 (IP地址)
```

这个过程会对网络请求带来一定的损耗，所以浏览器在第一次获取到IP地址后，会将其缓存起来。下次相同域名再次发起请求时，浏览器会先查找本地缓存，如果缓存有效，则会直接返回该IP地址，否则会继续开始寻址之旅。

- 首先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。

- 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。

- 如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。

- 如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。

##### memory cache（本地缓存）

memory cache 是浏览器为了加快读取缓存速度而进行的自身的优化行为，不受开发者控制，也不受 HTTP 协议头的约束。当资源被存入内存后，下次同样的请求将不再通过网络，而是直接访问内存，当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不再出现from memory cache的情况。

那有人会问了，那什么时候资源会被放入memory缓存呢

答案是几乎所有的网络请求资源都会根据相关的策略被浏览器自动加入到 memory cache 中。但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 注定只能是个“短期存储”。当数据量过大，即使网页不关闭，缓存依然会失效。

memory cache 机制保证了一个页面中如果有两个相同的请求 (例如两个 src 相同的 <img>，两个 href 相同的 <link>)都实际只会被请求最多一次，避免浪费。

##### disk cache（硬盘缓存）

硬盘缓存取决于HTTP中的响应头信息，它也是浏览器缓存中最重要的内容。因为你想啊，DNS缓存它主要是做一个ip地址查找并且是自主完成的，memory cache 也是不受控制，算是一个黑盒。所以剩下的可以受我们控制的硬盘缓存的重要性就不言而喻了，大多优化手段也是针对硬盘缓存。

HTTP所控制下的 disk cache 缓存分为强制缓存和协商缓存

##### 强制缓存 (也叫强缓存)

对于强缓存，控制它的字段分别是：Expires和Cache-Control，其中Cache-Control优先级比Expires高。

当客户端发出一个请求到服务器，服务器希望你把资源缓存起来，于是在响应头中加入了这些内容

```
Cache-Control: max-age=3600 我希望你把这个资源缓存起来，缓存时间是3600秒（1小时）
Expires: Thu, 10 Nov 2020 08:45:11 GMT 到达指定时间过期
Date: Thu, 30 Apr 2020 12:39:56 GMT
Etag:W/"121-171ca289ebf"，(后面协商缓存内容)这个资源的编号是W/"121-171ca289ebf"
Last-Modified:Thu, 30 Apr 2020 08:16:31 GMT，(后面协商缓存内容)这个资源的上一次修改时间
```

Cache-Control和 Expires分别是HTTP/1.1 和 HTTP/1.0的内容，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段我们都会设置。

浏览器收到这个响应之后就会做下面的事情

- 浏览器把这次请求得到的响应体缓存到本地文件中

- 浏览器标记这次请求的请求方法和请求路径

- 浏览器标记这次缓存的时间是3600秒

- 浏览器记录服务器的响应时间是格林威治时间2020-04-30 12:39:56

这一次的记录非常重要，它为以后浏览器要不要去请求服务器提供了依据。

之后当客户端收准备再次请求同样的地址时，它突然想起了一件事：我需要的东西在不在缓存里呢？

此时，客户端会到缓存中去寻找是否有缓存的资源，如下

![](./img/461e51029b60422f80cb202242fa6d64.awebp)

判断缓存是否有效就是通过把max-age + Date，得到一个过期时间，看看这个过期时间是否大于当前时间，如果是，则表示缓存还没有过期，仍然有效，如果不是，则表示缓存失效

##### 协商缓存 

一旦发现缓存无效，它**并不会简单的把缓存删除**，而是抱着一丝希望，想问问服务器，我**这个缓存还能继续使用吗？**

于是，浏览器向服务器发出了一个**带缓存的请求**

```
If-Modified-Since: Thu, 30 Apr 2020 08:16:31 GMT  亲，你曾经告诉我，这个资源的上一次修改时间是格林威治时间2020-04-30 08:16:31，请问这个资源在这个时间之后有发生变动吗？
If-None-Match: W/"121-171ca289ebf"  亲，你曾经告诉我，这个资源的编号是W/"121-171ca289ebf，请问这个资源的编号发生变动了吗？
```

之所以要发两个信息，是为了兼容不同的服务器，因为有些服务器只认If-Modified-Since，有些服务器只认If-None-Match，有些服务器两个都认,但是一般来说 If-None-Match 的优先级高于 If-Modified-Since

此时可能会产生两个结果

- 缓存失效：那么非常简单，服务器再次给予一个正常的响应（响应码200 带响应体），同时可以附带上新的缓存指令，浏览器缓存新的内容

- 缓存有效：服务器返回304重定向，并且响应头带上新的缓存指令，浏览器作出相应缓存动作。

![](./img/fd3db09a1cc04f7999eb14b0a021eefc.awebp)





